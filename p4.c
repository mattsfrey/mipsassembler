/* p4.c - Matthew Frey - MF969948 - csi 402 - 4/13/11

   usage: p4 <infile>

   This program will read in a TMIPS assembly file and
   process instructions from it. It makes a first pass
   reading in all the instructions and symbols into a
   linked list and puts all labels into a hash table.
   On a second pass it evaluates all the symbols and
   assembles the intructions, throwing errors as they
   arise. After this it will then either print a detailed
   error file or produce an object file in hexadecimal format.


*/


/***** Includes *********/
#include "p4.h"
#include "instruction_list.h"
#include "errorlist.h"
#include "hash.h"
#include "dataentry.h"


/***** argument constants *****/
#define ARGS_NEEDED 2
#define ARG1 1
#define ARG2 2


/* main method */
int main(int argc, char **argv)
{
    /************* Variables **********************/
    char file[FILE_LEN];     /* string for file name */
    char errfile[FILE_LEN];  /* string for error file name */
    FILE* fp = NULL;         /* file pointer for asm file */
    FILE* errfp = NULL;      /* file pointer to error file */
    char line[LINE_LEN];     /* line to be read in from asm file */

    char label[LABEL_LEN];       /* used to hold label */
    char* temp;                  /* used for splitting strings */
    char opname[OPCODE_LEN];     /* holds opcode name */
    char instargs[LINE_LEN];     /* holds instruction arguments */
    char immarg[IMMEDIATE_LEN];  /* holds immediate argument */
    char regarg[OPCODE_LEN];     /* holds register argument */
    char directive[LABEL_LEN];   /* holds data directive */

    /* used for splitting instruction args into sep args */
    char arg1[LINE_LEN];
    char arg2[LINE_LEN];
    char arg3[LINE_LEN];


    /* file read flags */
    int found_text = 0;     /* has .text been encountered */
    int found_data = 0;     /* has .data been found yet */
    int was_error = 0;      /* was the opcode an error? */

    int counter = 0;        /* line counter */
    int address = 0;        /* address counter */
    int addr = 0;           /* address holder */
    int i;                  /* iterator */


    /* list stuff */
    instlist *instructions;  /* instruction list */
    instnode *tempinst;      /* holder pointer   */

    errlist *errors;         /* error list */
    errnode *temperr;        /* temporary error node pointer */

    datalist *data;          /* data list */
    datanode *tempdata;      /* temporary data node */

    int tSize  = HASH_SIZE; /* size of table, read from first line of input */
    int genkey = 0;         /* key generated by hash function  */

    tnode* hash_head = NULL;    /* head node of the hash table */


    /************* BEGIN main executables *********/

    /* check if we have correct arguments */
    if (argc != ARGS_NEEDED)
    {
        fprintf(stderr, "Invalid arguments provided.\n");
        exit(1);
    }

    /* copy argument to file name */
    strcpy(file, argv[ARG1]);


    /****** begin to process asm file ******/

    /* attempt to open asm file */
    if ((fp = fopen(file, "r")) == NULL)
    {
        fprintf(stderr, "Error opening asm file: %s\n", file);
        exit(1);
    }


    /* OK we will attempt to do this, allocate list stuff
       then start reading file */

    /* allocate instructions list */
    instructions = malloc(sizeof(instlist));

    /* initialize instructions variables */
    instructions->head  = NULL;
    instructions->cur   = NULL;
    instructions->count = 0;

    /* allocate errors list */
    errors = malloc(sizeof(errlist));

    /* initialize instructions variables */
    errors->head  = NULL;
    errors->cur   = NULL;
    errors->count = 0;

    /* allocate data list */
    data = malloc(sizeof(datalist));

    /* initialize instructions variables */
    data->head  = NULL;
    data->cur   = NULL;
    data->count = 0;


    /* Loop through query file, executing commands */
    while (fgets(line, LINE_LEN, fp))
    {
        /* increment line counter */
        counter++;

        /* check to see if we're in text section yet */
        if (found_text==0)
        {
            if (strstr(line,".text"))
            {
                found_text = 1;
            }
            else
            {
                /* nothing, disregard line until .text has been found */
                continue;
            }
        }
        else if (found_data == 0)
        {
            /* check for data section */
            if (strstr(line,".data"))
            {
                /* we've hit the data section, skip out of this branch */
                found_data = 1;
                continue;
            }

            /* text has been found, but not yet to data, attempt to read instruction */

            /* check for blank line */
            if (isBlank(line))
            {
                /* do nothing, line is blank */
                continue;
            }

            /* check for comment */
            if (commentExists(line))
            {
                if (isComment(line))
                {
                    /* do nothing, line is a comment */
                    continue;
                }
                else
                {
                    /* ok, there is an inline comment after the instruction, strip it out */
                    stripComment(line);
                }
            }

            /* trim any whitespace characters off the end of the line
               if they exist */
            strcpy(line, trimWhiteSpace(line));

            /* OK we now have our raw instruction text */

            /* clear out our strings */
            strcpy(label,"");
            strcpy(opname,"");
            strcpy(instargs,"");


            /* check to see if we have a label, if so, split up the instruction */
            if (strchr(line,':'))
            {
                /* line has a label, need to insert into symbols table */
                temp = strtok(line," \t");
                strcpy(label, temp);

                strcpy(line, "");
                strcat(line, strtok(NULL, " \t"));
                temp = strtok(NULL, " \t");
                if (temp != NULL)
                {
                    strcat(line, " ");
                    strcat(line, temp);
                }

                /* strip colon */
                if (label[strlen(label)-1] == ':')
                {
                    label[strlen(label)-1] = '\0';
                }

                /* label is now set, and the remaining text in temp is the instruction */

                /* add label to symbols table */
                genkey = hashgen(label, tSize);

                /* check if symbol already exists, if so, generate error */
                if (checkHash(hash_head, genkey, label, &addr))
                {
                    /* allocate error node and fill details */
                    temperr = malloc(sizeof(errnode));
                    temperr->errtype = ERR_MULTSYMBOL;
                    temperr->lineno = counter;
                    strcpy(temperr->symbol, label);
                    add_err(errors, temperr);
                }
                else
                {
                    /* symbol isnt defined yet, add to hash table */
                    hash_head = addhashnode(hash_head, genkey, label, instructions->count);
                }
            }

            /* split line */
            temp = strtok(line, " \t");

            /* copy out opname */
            strcpy(opname, temp);
            temp = strtok(NULL, " \t");
            if (temp != NULL)
            {
                strcpy(instargs, temp);
            }

            /* clear out args */
            strcpy(arg1, "");
            strcpy(arg2, "");
            strcpy(arg3, "");

            /* attempt to split args */
            temp = strtok(instargs, ",");
            if (temp != NULL)
            {
                strcpy(arg1, temp);
            }
            temp = strtok(NULL, ",");
            if (temp != NULL)
            {
                strcpy(arg2, temp);
            }
            temp = strtok(NULL, ",");
            if (temp != NULL)
            {
                strcpy(arg3, temp);
            }


            /* allocate new instruction node and copy over the
                variables we know will be used for all instructions */
            tempinst = malloc(sizeof(instnode));
            tempinst->address = address;
            tempinst->lineno = counter;
            strcpy(tempinst->opcode_name, opname);
            strcpy(tempinst->label, label);

            /* zero out the dif fields of the instruction */
            strcpy(tempinst->rs1, "00000");
            strcpy(tempinst->rs2, "00000");
            strcpy(tempinst->rt,  "00000");
            strcpy(tempinst->sa,  "00000");
            strcpy(tempinst->imm, "0000000000000000");
            strcpy(tempinst->bin_inst,"");

            /* set error flag to 0 */
            was_error = 0;

            /* ok, label was handled if there was one, ready to insert instruction.
               we must go through all the dif opcode types, setting its variables
               appropriately  */
            if (strcmp(opname,"hlt")==0)
            {
                tempinst->inst_type = RTYPE;
                strcpy(tempinst->opcode_bin, "000000" );
            }
            else if (strcmp(opname,"add")==0)
            {
                tempinst->inst_type = RTYPE;
                strcpy(tempinst->opcode_bin, "000001" );
                strcpy(tempinst->rt, regToBin(arg1));
                strcpy(tempinst->rs1, regToBin(arg2));
                strcpy(tempinst->rs2, regToBin(arg3));
            }
            else if (strcmp(opname,"sub")==0)
            {
                tempinst->inst_type = RTYPE;
                strcpy(tempinst->opcode_bin, "000010" );
                strcpy(tempinst->rt, regToBin(arg1));
                strcpy(tempinst->rs1, regToBin(arg2));
                strcpy(tempinst->rs2, regToBin(arg3));
            }
            else if (strcmp(opname,"mul")==0)
            {
                tempinst->inst_type = RTYPE;
                strcpy(tempinst->opcode_bin, "000011" );
                strcpy(tempinst->rt, regToBin(arg1));
                strcpy(tempinst->rs1, regToBin(arg2));
                strcpy(tempinst->rs2, regToBin(arg3));
            }
            else if (strcmp(opname,"div")==0)
            {
                tempinst->inst_type = RTYPE;
                strcpy(tempinst->opcode_bin, "000100" );
                strcpy(tempinst->rt, regToBin(arg1));
                strcpy(tempinst->rs1, regToBin(arg2));
                strcpy(tempinst->rs2, regToBin(arg3));
            }
            else if (strcmp(opname,"mod")==0)
            {
                tempinst->inst_type = RTYPE;
                strcpy(tempinst->opcode_bin, "000101" );
                strcpy(tempinst->rt, regToBin(arg1));
                strcpy(tempinst->rs1, regToBin(arg2));
                strcpy(tempinst->rs2, regToBin(arg3));
            }
            else if (strcmp(opname,"move")==0)
            {
                tempinst->inst_type = RTYPE;
                strcpy(tempinst->opcode_bin, "000110" );
                strcpy(tempinst->rt, regToBin(arg1));
                strcpy(tempinst->rs1, regToBin(arg2));
            }
            else if (strcmp(opname,"and")==0)
            {
                tempinst->inst_type = RTYPE;
                strcpy(tempinst->opcode_bin, "000111" );
                strcpy(tempinst->rt, regToBin(arg1));
                strcpy(tempinst->rs1, regToBin(arg2));
                strcpy(tempinst->rs2, regToBin(arg3));
            }
            else if (strcmp(opname,"or")==0)
            {
                tempinst->inst_type = RTYPE;
                strcpy(tempinst->opcode_bin, "001000" );
                strcpy(tempinst->rt, regToBin(arg1));
                strcpy(tempinst->rs1, regToBin(arg2));
                strcpy(tempinst->rs2, regToBin(arg3));
            }
            else if (strcmp(opname,"xor")==0)
            {
                tempinst->inst_type = RTYPE;
                strcpy(tempinst->opcode_bin, "001001" );
                strcpy(tempinst->rt, regToBin(arg1));
                strcpy(tempinst->rs1, regToBin(arg2));
                strcpy(tempinst->rs2, regToBin(arg3));
            }
            else if (strcmp(opname,"com")==0)
            {
                tempinst->inst_type = RTYPE;
                strcpy(tempinst->opcode_bin, "001010" );
                strcpy(tempinst->rt, regToBin(arg1));
                strcpy(tempinst->rs1, regToBin(arg2));
            }
            else if (strcmp(opname,"sll")==0)
            {
                tempinst->inst_type = RTYPE;
                strcpy(tempinst->opcode_bin, "001011" );
                strcpy(tempinst->rt, regToBin(arg1));
                strcpy(tempinst->rs1, regToBin(arg2));
                strcpy(tempinst->sa, regToBin(arg3));
            }
            else if (strcmp(opname,"srl")==0)
            {
                tempinst->inst_type = RTYPE;
                strcpy(tempinst->opcode_bin, "001100" );
                strcpy(tempinst->rt,  regToBin(arg1));
                strcpy(tempinst->rs1, regToBin(arg2));
                strcpy(tempinst->sa,  regToBin(arg3));
            }
            else if (strcmp(opname,"sra")==0)
            {
                tempinst->inst_type = RTYPE;
                strcpy(tempinst->opcode_bin, "001101" );
                strcpy(tempinst->rt, regToBin(arg1));
                strcpy(tempinst->rs1, regToBin(arg2));
                strcpy(tempinst->sa, regToBin(arg3));
            }
            else if (strcmp(opname,"jr")==0)
            {
                tempinst->inst_type = RTYPE;
                strcpy(tempinst->opcode_bin, "001110" );
                strcpy(tempinst->rt, regToBin(arg1));
            }
            else if (strcmp(opname,"rdr")==0)
            {
                tempinst->inst_type = RTYPE;
                strcpy(tempinst->opcode_bin, "001111" );
                strcpy(tempinst->rt, regToBin(arg1));
            }
            else if (strcmp(opname,"prr")==0)
            {
                tempinst->inst_type = RTYPE;
                strcpy(tempinst->opcode_bin, "010000" );
                strcpy(tempinst->rt, regToBin(arg1));
            }
            else if (strcmp(opname,"prh")==0)
            {
                tempinst->inst_type = RTYPE;
                strcpy(tempinst->opcode_bin, "010001" );
                strcpy(tempinst->rt, regToBin(arg1));
            }
            else if (strcmp(opname,"li")==0)
            {
                tempinst->inst_type = ITYPE;
                strcpy(tempinst->opcode_bin, "010010" );
                strcpy(tempinst->rt, regToBin(arg1));
                strcpy(tempinst->imm, immToBin(arg2));
            }
            else if (strcmp(opname,"addi")==0)
            {
                tempinst->inst_type = ITYPE;
                strcpy(tempinst->opcode_bin, "010011" );
                strcpy(tempinst->rt, regToBin(arg1));
                strcpy(tempinst->rs1, regToBin(arg2));
                strcpy(tempinst->imm, immToBin(arg3));
            }
            else if (strcmp(opname,"subi")==0)
            {
                tempinst->inst_type = ITYPE;
                strcpy(tempinst->opcode_bin, "010100" );
                strcpy(tempinst->rt, regToBin(arg1));
                strcpy(tempinst->rs1, regToBin(arg2));
                strcpy(tempinst->imm, immToBin(arg3));
            }
            else if (strcmp(opname,"muli")==0)
            {
                tempinst->inst_type = ITYPE;
                strcpy(tempinst->opcode_bin, "010101" );
                strcpy(tempinst->rt, regToBin(arg1));
                strcpy(tempinst->rs1, regToBin(arg2));
                strcpy(tempinst->imm, immToBin(arg3));
            }
            else if (strcmp(opname,"divi")==0)
            {
                tempinst->inst_type = ITYPE;
                strcpy(tempinst->opcode_bin, "010110" );
                strcpy(tempinst->rt, regToBin(arg1));
                strcpy(tempinst->rs1, regToBin(arg2));
                strcpy(tempinst->imm, immToBin(arg3));
            }
            else if (strcmp(opname,"modi")==0)
            {
                tempinst->inst_type = ITYPE;
                strcpy(tempinst->opcode_bin, "010111" );
                strcpy(tempinst->rt, regToBin(arg1));
                strcpy(tempinst->rs1, regToBin(arg2));
                strcpy(tempinst->imm, immToBin(arg3));
            }
            else if (strcmp(opname,"lwb")==0)
            {
                tempinst->inst_type = ITYPE;
                strcpy(tempinst->opcode_bin, "011000" );
                strcpy(tempinst->rt, regToBin(arg1));

                /* need to do some parsing for the base + register stuff */
                temp = strtok(arg2,"(");
                strcpy(immarg, temp);
                temp = strtok(NULL, "()");
                strcpy(regarg,temp);

                strcpy(tempinst->imm, immToBin(immarg));
                strcpy(tempinst->rs1, regToBin(regarg));
            }
            else if (strcmp(opname,"swb")==0)
            {
                tempinst->inst_type = ITYPE;
                strcpy(tempinst->opcode_bin, "011001" );
                strcpy(tempinst->rt, regToBin(arg1));

                /* need to do some parsing for the base + register stuff */
                temp = strtok(arg2,"(");
                strcpy(immarg, temp);
                temp = strtok(NULL, "()");
                strcpy(regarg,temp);

                strcpy(tempinst->imm, immToBin(immarg));
                strcpy(tempinst->rs1, regToBin(regarg));

            }
            else if (strcmp(opname,"lwa")==0)
            {
                tempinst->inst_type = JTYPE;
                strcpy(tempinst->opcode_bin, "011010" );
                strcpy(tempinst->rt, regToBin(arg1));
                strcpy(tempinst->symbol, arg2);
            }
            else if (strcmp(opname,"swa")==0)
            {
                tempinst->inst_type = JTYPE;
                strcpy(tempinst->opcode_bin, "011011" );
                strcpy(tempinst->rt, regToBin(arg1));
                strcpy(tempinst->symbol, arg2);
            }
            else if (strcmp(opname,"j")==0)
            {
                tempinst->inst_type = JTYPE;
                strcpy(tempinst->opcode_bin, "011100" );
                strcpy(tempinst->symbol, arg1);
            }
            else if (strcmp(opname,"jal")==0)
            {
                tempinst->inst_type = JTYPE;
                strcpy(tempinst->opcode_bin, "011101" );
                strcpy(tempinst->symbol, arg1);
            }
            else if (strcmp(opname,"jeq")==0)
            {
                tempinst->inst_type = JTYPE;
                strcpy(tempinst->opcode_bin, "011110" );
                strcpy(tempinst->rt, regToBin(arg1));
                strcpy(tempinst->rs1, regToBin(arg2));
                strcpy(tempinst->symbol, arg3);

            }
            else if (strcmp(opname,"jne")==0)
            {
                tempinst->inst_type = JTYPE;
                strcpy(tempinst->opcode_bin, "011111" );
                strcpy(tempinst->rt, regToBin(arg1));
                strcpy(tempinst->rs1, regToBin(arg2));
                strcpy(tempinst->symbol, arg3);
            }
            else if (strcmp(opname,"jlt")==0)
            {
                tempinst->inst_type = JTYPE;
                strcpy(tempinst->opcode_bin, "100000" );
                strcpy(tempinst->rt, regToBin(arg1));
                strcpy(tempinst->rs1, regToBin(arg2));
                strcpy(tempinst->symbol, arg3);
            }
            else if (strcmp(opname,"jle")==0)
            {
                tempinst->inst_type = JTYPE;
                strcpy(tempinst->opcode_bin, "100001" );
                strcpy(tempinst->rt, regToBin(arg1));
                strcpy(tempinst->rs1, regToBin(arg2));
                strcpy(tempinst->symbol, arg3);
            }
            else if (strcmp(opname,"jgt")==0)
            {
                tempinst->inst_type = JTYPE;
                strcpy(tempinst->opcode_bin, "100010" );
                strcpy(tempinst->rt, regToBin(arg1));
                strcpy(tempinst->rs1, regToBin(arg2));
                strcpy(tempinst->symbol, arg3);
            }
            else if (strcmp(opname,"jge")==0)
            {
                tempinst->inst_type = JTYPE;
                strcpy(tempinst->opcode_bin, "100011" );
                strcpy(tempinst->rt, regToBin(arg1));
                strcpy(tempinst->rs1, regToBin(arg2));
                strcpy(tempinst->symbol, arg3);
            }
            else
            {
                /* bad opcode given, throw error */
                temperr = malloc(sizeof(errnode));
                temperr->errtype = ERR_OPCODE;
                temperr->lineno = counter;
                strcpy(temperr->opcode, opname);

                add_err(errors,temperr);

                /* set was_error flag to true */
                was_error = 1;

            }
            if (was_error == 0)
            {
                /* there was no error so add the node to the instruction list */
                add_node(instructions, tempinst);

                /* increment address */
                address++;
            }
        }
        else
        {
            /* we're now in the data section, look for a directive */

            /* check for blank line */
            if (isBlank(line))
            {
                /* do nothing, line is blank */
                continue;
            }

            /* check for comment */
            if (commentExists(line))
            {
                if (isComment(line))
                {
                    /* do nothing, line is a comment */
                    continue;
                }
                else
                {
                    /* ok, there is an inline comment after the instruction, strip it out */
                    stripComment(line);
                }
            }

            /* clear out string variables */
            strcpy(label, "");
            strcpy(instargs, "");
            strcpy(arg1, "");
            strcpy(arg2, "");
            strcpy(directive, "");


            /* trim any whitespace characters off the end of the line
               if they exist */
            strcpy(line, trimWhiteSpace(line));

            /* OK so at this point we should have a label, directive, arguments line */
            temp = strtok(line," ");
            strcpy(label, temp);

            /* split into directive and args */
            temp = strtok(NULL," ");
            strcpy(directive, temp);

            temp = strtok(NULL, "");
            if (temp != NULL)
            {
                strcpy(instargs,temp);
            }
            /* strip off the colon */
            if (label[strlen(label)-1] == ':')
            {
                label[strlen(label)-1] = '\0';
            }

            /* add label to symbols table */
            genkey = hashgen(label, tSize);
            /* check if symbol already exists, if so, generate error */
            if (checkHash(hash_head, genkey, label, &addr))
            {
                /* allocate error node and fill details */
                temperr = malloc(sizeof(errnode));
                temperr->errtype = ERR_MULTSYMBOL;
                temperr->lineno = counter;
                strcpy(temperr->symbol, label);
                add_err(errors, temperr);
            }
            else
            {
                /* symbol isnt defined yet, add to hash table */
                hash_head = addhashnode(hash_head, genkey, label, address);
            }

            /* check for .word directive */
            if (strcmp(directive, ".word")==0)
            {
                /* split args at the colon */
                temp = strtok(instargs, ":");
                strcpy(arg1, temp);
                temp = strtok(NULL, ":");
                strcpy(arg2, temp);

                /* loop through and add data field for X amount of entries */
                for (i=0; i<atoi(arg2); i++)
                {
                    /* copy over arg for formatting */
                    strcpy(arg3, arg1);

                    /* allocate new data node and fill details */
                    tempdata = malloc(sizeof(datanode));
                    tempdata->address = address;
                    tempdata->lineno  = counter;
                    strcpy(tempdata->label, label);
                    strcpy(tempdata->binval, numTo32Bin(arg3));
                    strcpy(arg3,tempdata->binval);
                    strcpy(tempdata->hex_val, binToHex32(arg3));

                    /* add new data node to data list */
                    add_datanode(data, tempdata);

                    /* increment address counter */
                    address++;
                }
            }
            /* check for .resw directive */
            else if (strcmp(directive, ".resw")==0)
            {
                /* copy 0 to arg because resw statements zero out the data field */
                strcpy(arg1,"0");

                /* loop through and create field for X amount */
                for (i=0; i<atoi(instargs); i++)
                {
                    /* copy arg for formatting */
                    strcpy(arg3, arg1);

                    /* allocate new data node and fill details */
                    tempdata = malloc(sizeof(datanode));
                    tempdata->address = address;
                    tempdata->lineno  = counter;
                    strcpy(tempdata->label, label);
                    strcpy(tempdata->binval, numTo32Bin(arg3));
                    strcpy(arg3,tempdata->binval);
                    strcpy(tempdata->hex_val, binToHex32(arg3));

                    /* add new data node to data list */
                    add_datanode(data, tempdata);

                    /* increment address counter */
                    address++;
                }
            } /* end if .resw */
        } /* end: else data section */
    } /* end while fgets */

    /* close file */
    fclose(fp);

    /* alright file has been processed at this point.
       instructions and data directives are in their respective lists.
       we must now go through both and assemble them into binary and
       then into hex. symbols must be evaluated through the hash table
       and errors generated if they are invalid */

    /* set traversal node to head of list */
    instructions->cur = instructions->head;

    /* loop through and assemble instructions */
    while (instructions->cur != NULL)
    {
        /* check for RTYPE instruction and format acoordingly */
        if (instructions->cur->inst_type == RTYPE)
        {
            /* assemble binary instruction */
            sprintf(instructions->cur->bin_inst, "%s%s%s%s%s000000", instructions->cur->opcode_bin, instructions->cur->rs1,
                    instructions->cur->rs2, instructions->cur->rt, instructions->cur->sa);
            /* copy to temp var */
            strcpy(line,instructions->cur->bin_inst);

            /* convert to hex and copy to hex field in node */
            strcpy(instructions->cur->hex_inst, binToHex32(line));
        }
        /* check for ITYPE instruction and format acoordingly */
        else if (instructions->cur->inst_type == ITYPE)
        {
            /* assemble binary instruction */
            sprintf(instructions->cur->bin_inst, "%s%s%s%s", instructions->cur->opcode_bin, instructions->cur->rs1,
                    instructions->cur->rt, instructions->cur->imm);
            /* copy to temp var */
            strcpy(line,instructions->cur->bin_inst);

            /* convert to hex and copy to hex field in node */
            strcpy(instructions->cur->hex_inst, binToHex32(line));
        }
        /* check for JTYPE instruction and format acoordingly */
        else if (instructions->cur->inst_type == JTYPE)
        {
            /* check and see if symbol is defined in the hash table */
            if (checkHash(hash_head, hashgen(instructions->cur->symbol, tSize), instructions->cur->symbol, &addr))
            {
                /* symbol exists, so assemble instruction */
                sprintf(line,"%d",addr);
                sprintf(instructions->cur->bin_inst, "%s%s%s%s", instructions->cur->opcode_bin, instructions->cur->rs1,
                        instructions->cur->rt, immToBin(line));
                strcpy(line,instructions->cur->bin_inst);

                /* convert to hex and copy to hex field in node */
                strcpy(instructions->cur->hex_inst, binToHex32(line));
            }
            else
            {
                /* need to generate an error, symbol is invalid */

                /* allocate error node and fill details */
                temperr = malloc(sizeof(errnode));
                temperr->errtype = ERR_UNDEFSYMBOL;
                temperr->lineno = instructions->cur->lineno;
                strcpy(temperr->symbol, instructions->cur->symbol);

                /* add error node to error list */
                add_err(errors, temperr);
            }
        }
        /* traverse to next node in instructions list */
        instructions->cur = instructions->cur->next;
    } /* end while */

    /* instructions are now assembled in hex, ready to be printed */

    /* if errors exist, write to error file */

    if (errors->count > 0 )
    {
        /* attempt to open asm file */
        if ((fp = fopen(file, "r")) == NULL)
        {
            fprintf(stderr, "Error opening asm file: %s\n", file);
            exit(1);
        }

        /* format error file name */
        sprintf(errfile, "%s.err", strtok(file, "."));

        /* attempt to open error file */
        if ((errfp = fopen(errfile, "w")) == NULL)
        {
            fprintf(stderr, "Error opening error file: %s\n", errfile);
            exit(1);
        }

        /* loop through asm file and write all lines to error file with
           prefixed line numbers */
        /*reset counter to 0 */
        counter = 0;

        while (fgets(line, LINE_LEN, fp))
        {
            /* increment line counter */
            counter++;
            fprintf(errfp,"%2d   %s", counter, line);
        }
        /* close asm file */
        fclose(fp);

        /* clear some lines in error file */
        fprintf(errfp, "\n");

        fprintf(errfp, "Errors detected:\n\n");

        /* loop through errors and generate error report */
        errors->cur = errors->head;
        while (errors->cur != NULL)
        {
            /* if error i opcode, show proper message */
            if (errors->cur->errtype == ERR_OPCODE)
            {
                fprintf(errfp,"  line %2d:  Illegal opcode.\n", errors->cur->lineno);

            }
            /* else show message for undefined symbol */
            else if (errors->cur->errtype == ERR_UNDEFSYMBOL)
            {
                fprintf(errfp,"  line %2d:  Undefined symbol used.\n", errors->cur->lineno);
            }

            /* traverse to next error */
            errors->cur = errors->cur->next;
        }

        /* clear a line */
        fprintf(errfp, "\n");

        /* check for multiply defined symbols */
        /* loop through errors */
        errors->cur = errors->head;
        while (errors->cur != NULL)
        {
            /* check for multiple symbol errors */
            if (errors->cur->errtype == ERR_MULTSYMBOL)
            {
                /* print title */
                fprintf(errfp,"Multiply defined symbol(s):\n\n");

                /* loop through and print all multiple symbol errors */
                errors->cur = errors->head;
                while (errors->cur != NULL)
                {
                    if (errors->cur->errtype == ERR_MULTSYMBOL)
                    {
                        fprintf(errfp, "  %s\n", errors->cur->symbol);
                    }
                    errors->cur = errors->cur->next;
                }
                break;
            }
            /* traverse to next error node */
            errors->cur = errors->cur->next;
        } /* end while */

        /* clear a line */
        fprintf(errfp, "\n");

        /* check for undefined  symbols */
        /* loop through errors */
        errors->cur = errors->head;
        while (errors->cur != NULL)
        {
            if (errors->cur->errtype == ERR_UNDEFSYMBOL)
            {
                /* print title */
                fprintf(errfp,"Undefined symbol(s):\n\n");

                /* loop through and print all undefined symbol errors */
                errors->cur = errors->head;
                while (errors->cur != NULL)
                {
                    if (errors->cur->errtype == ERR_UNDEFSYMBOL)
                    {
                        fprintf(errfp, "  %s\n", errors->cur->symbol);
                    }
                    /* traverse to next node */
                    errors->cur = errors->cur->next;
                }
                break;
            }
            /* traverse to next node */
            errors->cur = errors->cur->next;
        } /* end while */


        /* close error file */
        fclose(errfp);

    } /* end errors */
    else
    {
        /* ok we got no errors so write the obj file */

        /* format object file name */
        sprintf(file, "%s.obj", strtok(file, "."));

        /* attempt to open object file */
        if ((fp = fopen(file, "w")) == NULL)
        {
            fprintf(stderr, "Error opening obj file: %s\n", file);
            exit(1);
        }

        /* loop through instructions writing them to the obj file */
        instructions->cur = instructions->head;

        while (instructions->cur != NULL)
        {
            /* print instruction in hex: address - instruction */
            fprintf(fp,"%s\t%s\n", addrToHex(instructions->cur->address, line), instructions->cur->hex_inst);

            /* traverse to next instruction node */
            instructions->cur = instructions->cur->next;
        }

        /* now write data */
        data->cur = data->head;
        while (data->cur != NULL)
        {
            /* format and print data entry */
            fprintf(fp,"%s\t%s\n", addrToHex(data->cur->address, line), data->cur->hex_val);

            /* traverse to next data entry node */
            data->cur = data->cur->next;
        }
    }

    /* yay, we're finally done and can delete our data structures */
    delete_errlist(errors);
    delete_list(instructions);
    delete_datalist(data);
    deletetable(hash_head);

    /**************** END main executables *********************/

    /* exit program */
    return 0;
}

